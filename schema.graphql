# Vault

type Balancer @entity {
"balancer ID"
id: ID!
"how many pools"
poolCount: Int!
"choose which pool"
pools: [Pool!] @derivedFrom(field: "vaultID")

"how many liquidity pool has"
totalLiquidity: BigDecimal!
"quantity of swaps"
totalSwapCount: BigInt!
"how much volume has been swapped"
totalSwapVolume: BigDecimal!
"how much fees collected"
totalSwapFee: BigDecimal!
}

type Pool @entity {
"smart contract id of pool"
id: ID!
"address of user"
address: Bytes!
"which tpe of balancer pool"
poolType: String
"version type of pool"
poolTypeVersion: Int
"time-based pause configuration"
factory: Bytes
"strategy type (1 or 2)"
strategyType: Int!
"check wether oracle is enabled"
oracleEnabled: Boolean!
"pool token symbol"
symbol: String
"pool token name"
name: String
"check wether oracle is enabled"
swapEnabled: Boolean!
"pool swap fee"
swapFee: BigDecimal!
"pool owner address"
owner: Bytes

"total weight"
totalWeight: BigDecimal
"total swap volume in USD"
totalSwapVolume: BigDecimal!
"total swap fee in USD"
totalSwapFee: BigDecimal!
"total liqidity in pool"
totalLiquidity: BigDecimal!
"total pool token shares"
totalShares: BigDecimal!

"block time pool was created"
createTime: Int!
"pool swaps count"
swapsCount: BigInt!
"total number of LP in that pool"
holdersCount: BigInt!

"vault ID"
vaultID: Balancer!
"Pool creation transaction id"
tx: Bytes

"array of token address in pool"
tokensList: [Bytes!]!

"tokens in pool"
tokens: [PoolToken!] @derivedFrom(field: "poolId")
"swaps in pool"
swaps: [Swap!] @derivedFrom(field: "poolId")
"shares in pool"
shares: [PoolShare!] @derivedFrom(field: "poolId")
"snapshot of pool"
snapshots: [PoolSnapshot!] @derivedFrom(field: "pool")
"pool historical values and liquidity"
historicalValues: [PoolHistoricalLiquidity!] @derivedFrom(field: "poolId")

# LiquidityBootstrappingPool Only

"weight update values"
weightUpdates: [GradualWeightUpdate!] @derivedFrom(field: "poolId")

# StablePool Only

"amplification paramenters"
amp: BigInt

# MetaStablePool and LinearPool Only

"price parameters"
priceRateProviders: [PriceRateProvider!] @derivedFrom(field: "poolId")

# ConvergentCurvePool (Element) Only

"principal token"
principalToken: Bytes
"base token"
baseToken: Bytes
"pool expiry time"
expiryTime: BigInt
"unit seconds"
unitSeconds: BigInt

# InvestmentPool Only

"pool management fee"
managementFee: BigDecimal

# LinearPool Only

"pool main index"
mainIndex: Int
"pool wrapped index"
wrappedIndex: Int
"lower target"
lowerTarget: BigDecimal
"upper targer"
upperTarget: BigDecimal

# Gyro2Pool Only

"square root of alpha"
sqrtAlpha: BigDecimal
"square root of beta"
sqrtBeta: BigDecimal

# Gyro3Pool Only

"cube root of alpha"
root3Alpha: BigDecimal

# GyroEPool Only

c: BigDecimal
s: BigDecimal
tauAlphaX: BigDecimal
tauAlphaY: BigDecimal
tauBetaX: BigDecimal
tauBetaY: BigDecimal
u: BigDecimal
v: BigDecimal
w: BigDecimal
z: BigDecimal
dSq: BigDecimal

# GyroEPool+FXPool Only

"alpha of GryroEPool and FXPool"
alpha: BigDecimal
"beta of GryroEPool and FXPool"
beta: BigDecimal
"lamda of GryroEPool and FXPool"
lambda: BigDecimal

# FXPool Only

"delta of FXPool"
delta: BigDecimal
"epsilon of FXPool"
epsilon: BigDecimal

# Composable and WeightedV2 Only

"swap fee of composable and weighted pool"
protocolSwapFeeCache: BigDecimal
"yield of composable and weighted pool"
protocolYieldFeeCache: BigDecimal
"Aum fee of composable and weighted pool"
protocolAumFeeCache: BigDecimal
}

type PoolContract @entity {
"contract of pool"
id: ID!
"a unigue identifier for each pool"
pool: Pool!
}

type PoolToken @entity {
"pool token ID"
id: ID!
"a unigue identifier for each pool"
poolId: Pool
"token id"
token: Token!
"mint / burn address"
assetManager: Bytes!
"pool token symbol"
symbol: String!
"name of pool token symbol"
name: String!
"the number of decimals for your token"
decimals: Int!
"pool token address"
address: String!
"conversion of token swapped"
priceRate: BigDecimal!
"token balance of pool token"
balance: BigDecimal!
"cash balance of pool token"
cashBalance: BigDecimal!
"managed balance"
managedBalance: BigDecimal!
"management values"
managements: [ManagementOperation!] @derivedFrom(field: "poolTokenId")

# WeightedPool Only

"percentage of token of weighted pool"
weight: BigDecimal

# ComposableStablePool Only

"stable pools only"
isExemptFromYieldProtocolFee: Boolean

# FXPool Only

"assimilator for FX Pool"
assimilator: Bytes
}

type PriceRateProvider @entity {
"Id of contract"
id: ID!
"a unigue identifier for each pool"
poolId: Pool!
"token of the pool"
token: PoolToken!
"address of each token"
address: Bytes!
"rate of quoted swap"
rate: BigDecimal
"timestamp of last quoted price"
lastCached: Int
"how long estimate rate will last"
cacheDuration: Int
"timestamp of price expiration"
cacheExpiry: Int
}

type PoolShare @entity {
"pool share ID"
id: ID!
"user wallet address"
userAddress: User!
"a unigue identifier for each pool"
poolId: Pool!
"balance of pool"
balance: BigDecimal!
}

type User @entity {
"user ID"
id: ID!
"how many shares user owns"
sharesOwned: [PoolShare!] @derivedFrom(field: "userAddress")
"how many swaps user has made"
swaps: [Swap!] @derivedFrom(field: "userAddress") "how many swaps user has made"
"balance for user"
userInternalBalances: [UserInternalBalance!]
@derivedFrom(field: "userAddress")
}

type UserInternalBalance @entity {
"user internal balance ID"
id: ID!
"wallet address"
userAddress: User
"token checking balance on"
token: Bytes!
"balance of token"
balance: BigDecimal!
}

type GradualWeightUpdate @entity {
"ID"  
id: ID!
"a unigue identifier for each pool"
poolId: Pool!
"scheduled time LP token weight change"
scheduledTimestamp: Int!
"start time of update"
startTimestamp: BigInt!
"end time of update"
endTimestamp: BigInt!
"weight of tokens in each LP pair before update"
startWeights: [BigInt!]!
"weight of tokens in each LP pair ater update"
endWeights: [BigInt!]!
}

type AmpUpdate @entity {
"amp update"
id: ID!
"a unigue identifier for each pool"
poolId: Pool!
"scheduled time of amp update"
scheduledTimestamp: Int!
"Start time of update"
startTimestamp: BigInt!
"end time of update"
endTimestamp: BigInt!
"amount of amp prior to update"
startAmp: BigInt!
"amount of amp after update"
endAmp: BigInt!
}

type SwapFeeUpdate @entity {
"swap-{ Transaction hash }-{ Log index }"
id: ID!
"a unigue identifier for each pool"
pool: Pool!
"schedule time for swap"
scheduledTimestamp: Int!
"start time for swap"
startTimestamp: BigInt!
"end time for swap"
endTimestamp: BigInt!
"percent of fees when swap starts"
startSwapFeePercentage: BigDecimal!
"percent of fees when swap ends"
endSwapFeePercentage: BigDecimal!  
}

type Swap @entity {
"swap-{ Transaction hash }-{ Log index }"
id: ID!
"pool controller"
caller: Bytes!
"token deposited into pool"
tokenIn: Bytes!
"symbol of token swapped in"
tokenInSym: String!
"token withdrawn from pool"
tokenOut: Bytes!
"symbol of token swapped out"
tokenOutSym: String!
"total native token deposited"
tokenAmountIn: BigDecimal!
"total native token withdrawn"
tokenAmountOut: BigDecimal!
"value in USD"
valueUSD: BigDecimal!
"a unigue identifier for each pool"
poolId: Pool!
"user wallet address"
userAddress: User!
"timestamp of this even"
timestamp: Int!
"fee for swap"
tx: Bytes!
}

enum InvestType {
Join
Exit
}

type JoinExit @entity {
"ID of the pool you're interacting with"
id: ID!
"JoinKind or ExitKind"
type: InvestType!
"address of sender"
sender: Bytes!
"amounts during entry and exit"
amounts: [BigDecimal!]!
"value of join in USD"
valueUSD: BigDecimal
"pool ID"
pool: Pool!
"Joins encodes JoinKind, Exits encode ExitKind"
user: User!
"time stamp of join or exit"
timestamp: Int!
"fee paid"
tx: Bytes!
}

type LatestPrice @entity {
"ID"
id: ID!
"token address"
asset: Bytes!
"address of stable asset"
pricingAsset: Bytes!
"last pool which set price"
poolId: Pool!
"all the latest prices"
price: BigDecimal!
"last block that prices were updated"
block: BigInt!
}

type PoolHistoricalLiquidity @entity {
"ID"
id: ID!
"a unigue identifier for each pool"
poolId: Pool!
"total pool shares"
poolTotalShares: BigDecimal!
"total value, priced in the stable asset - ie USD"
poolLiquidity: BigDecimal!
"total pool value"
poolShareValue: BigDecimal!
"address of stable asset"
pricingAsset: Bytes!
"last block that prices were updated"
block: BigInt!
}

type TokenPrice @entity {
"address of token + address of stablecoin-poolId"
id: ID!
"a unigue identifier for each pool"
poolId: Pool!
"list of assets"
asset: Bytes!
"amount of token"
amount: BigDecimal!
"address of stable asset"
pricingAsset: Bytes!
"price of token"
price: BigDecimal!
"last block that prices were updated"
block: BigInt!
"time price is checked"
timestamp: Int!
}

enum OperationType {
Deposit
Withdraw
Update
}

type ManagementOperation @entity {
"ID"
id: ID!
"operation type"
type: OperationType!
"change in cash since last cash delta point"
cashDelta: BigDecimal!
"change in managed amount since last delta point"
managedDelta: BigDecimal!
"a unigue identifier for each pool"
poolTokenId: PoolToken!
"timestamp operation occurs"
timestamp: Int!
}

type PoolSnapshot @entity {
"pool snapshot ID"
id: ID!
"name of pools included"
pool: Pool!
"amount of pools included"
amounts: [BigDecimal!]!
"total shares of pool before vote"
totalShares: BigDecimal!
"total volume of pool before vote"
swapVolume: BigDecimal!
"swap fee of pool before vote"
swapFees: BigDecimal!
"total liquidity of pool before vote"
liquidity: BigDecimal!
"total swaps count"
swapsCount: BigInt!
"total holders count"
holdersCount: BigInt!
"time snapshot occurs"
timestamp: Int!
}

type Token @entity {
"Smart contract address of the token"
id: ID!
"symbol of token"
symbol: String
"name of token"
name: String
"the number of decimals for your token"
decimals: Int!
"token address"
address: String!
"total balance of tokens across balancer"
totalBalanceUSD: BigDecimal!
"total unrealized balance"
totalBalanceNotional: BigDecimal!
"total volume in fiat (usd)"
totalVolumeUSD: BigDecimal!
"total unrealized volume"
totalVolumeNotional: BigDecimal!
"total swap count for token"
totalSwapCount: BigInt!
"latest price of token, updated when pool liquidity changes"
latestPrice: LatestPrice
"latest price of token in USD, updated when pool liquidity changes"
latestUSDPrice: BigDecimal
"pool entity associated with the token, if it is a Balancer pool"
pool: Pool
}

type TokenSnapshot @entity {
"token address + dayId"
id: ID!
"which token or crypto"
token: Token!
"timestamp representing the start of day in UTC"
timestamp: Int!
"total balance of tokens across balancer"
totalBalanceUSD: BigDecimal!
"underlying asset balance"
totalBalanceNotional: BigDecimal!
"amount of volume the token has moved on this day"
totalVolumeUSD: BigDecimal!
"underyling asset volume"
totalVolumeNotional: BigDecimal!
"total swap count accross balancer"
totalSwapCount: BigInt!
}

type TradePair @entity {
"Token Address - Token Address"
id: ID!
"Token 1 of trading pair"
token0: Token!
"Token 2 of trading part"
token1: Token!
"Total swap volume of pair"
totalSwapVolume: BigDecimal!
"Total swap fees of pair"
totalSwapFee: BigDecimal!
}

type TradePairSnapshot @entity {
"user eth address"
id: ID!
"trading pair used in vote"
pair: TradePair!
"time snapshot took place"
timestamp: Int!
"total volume at time of snapshot"
totalSwapVolume: BigDecimal!
"total swap fees at time of snapshot"
totalSwapFee: BigDecimal!
}

type BalancerSnapshot @entity {
"User eth address"
id: ID!
"which vault is associated to vote"
vault: Balancer!
"time snapshot took place"
timestamp: Int!
"how many pools in vote"
poolCount: Int!
"total liquidity of pools in vote"
totalLiquidity: BigDecimal!
"total swapcount of pools in vote"
totalSwapCount: BigInt!
"total swap volome of pools in vote"
totalSwapVolume: BigDecimal!
"total swap fees of pools in vote"
totalSwapFee: BigDecimal!
}
