# Vault
type Balancer @entity {
    id: ID!
    color: String!                                      # Bronze, Silver, Gold
    poolCount: Int!                                     # Number of pools
    finalizedPoolCount: Int!                            # Number of finalized pools
    pools: [Pool!] @derivedFrom(field: "vaultID")
    txCount: BigInt!                                    # Number of txs
    totalLiquidity: BigDecimal!                         # All the pools liquidity value in USD
    totalSwapVolume: BigDecimal!                        # All the swap volume in USD
    totalSwapFee: BigDecimal!                           # All the swap fee in USD
}

type Pool @entity {
    id: ID!                                              # Pool address
    controller: Bytes!                                   # Controller address
    strategyType: Int!                                   # Strategy Type
    symbol: String                                      # Pool token symbol
    name: String                                        # Pool token name
    active: Boolean!                                     # isActive
    swapFee: BigDecimal!                                # Swap Fees
    totalWeight: BigDecimal!
    totalSwapVolume: BigDecimal!                        # Total swap volume in USD
    totalSwapFee: BigDecimal!                           # Total swap fee in USD
    liquidity: BigDecimal!                              # Pool liquidity value in USD
    tokensList: [Bytes!]!                               # Temp workaround until graph supports filtering on derived field
    tokens: [PoolToken!] @derivedFrom(field: "poolId")
    joinsCount: BigInt!                                 # liquidity has been added
    exitsCount: BigInt!                                 # liquidity has been removed
    createTime: Int!                                    # Block time pool was created
    tokensCount: BigInt!                                # Number of tokens in the pool
    swapsCount: BigInt!
    vaultID: Balancer!
    tx: Bytes                                           # Pool creation transaction id
    swaps: [Swap!] @derivedFrom(field: "poolId")
    tokenized: Boolean!
    poolTokenizer: PoolTokenizer
    historicalValues: [PoolHistoricalLiquidity!] @derivedFrom(field: "poolId")
    weights: [BigInt!]                                  # array of weights (for weighted pools)
    amp: BigInt                                         # amplification (for stable pools)
}

type PoolToken @entity {
    id: ID!                                             # poolId + token address
    poolId: Pool!
    symbol: String
    name: String
    decimals: Int!
    address: String!
    balance: BigDecimal!
    invested: BigDecimal!
    investments: [Investment!] @derivedFrom(field: "poolTokenId")
}

# distinct from the pool type, which is just the vault's notion of a pool
type PoolTokenizer @entity {
    id: ID!                                             # Pool address
    poolId: Pool!
    totalShares: BigDecimal!                            # Total pool token shares
    holdersCount: BigInt!                               # Number of addresses holding a positive balance of BPT
    shares: [PoolShare!] @derivedFrom(field: "poolTokenizerId")
}

type PoolShare @entity {
    id: ID!                                             # poolId + userAddress
    userAddress: User!
    poolTokenizerId: PoolTokenizer!
    poolId: Pool!
    balance: BigDecimal!
}

type User @entity {
    id: ID!
    sharesOwned: [PoolShare!]  @derivedFrom(field: "userAddress")
    swaps: [Swap!]  @derivedFrom(field: "userAddress")
    userBalances: [UserBalance!]  @derivedFrom(field: "userAddress")
}

type UserBalance @entity {
  id:  ID!
  userAddress: User
  token: Bytes!
  balance: BigDecimal!
}

type Swap @entity {
    id: ID!
    caller: Bytes!
    tokenIn: Bytes!
    tokenInSym: String!
    tokenOut: Bytes!
    tokenOutSym: String!
    tokenAmountIn: BigDecimal!
    tokenAmountOut: BigDecimal!
    poolId: Pool!
    userAddress: User!                      # User address that initiates the swap
    timestamp: Int!
}

type LatestPrice @entity {
  id: ID!
  asset: Bytes!
  pricingAsset: Bytes! # address of stable asset
  poolId: Pool! # last pool which set price
  price:  BigDecimal! # all the latest prices
  block: BigInt! # last block that prices were updated
}

type PoolHistoricalLiquidity @entity {
  id: ID!
  poolId: Pool!
  poolLiquidity: BigDecimal! # total value, priced in the stable asset - ie USD
  pricingAsset: Bytes! # address of stable asset
  block: BigInt!
}

type TokenPrice @entity {
  id: ID! # address of token + address of stablecoin-poolId
  poolId: Pool!
  asset: Bytes!
  amount: BigDecimal!
  pricingAsset: Bytes! # address of stable asset
  price: BigDecimal!
  block: BigInt!
  timestamp: BigInt!
}

type Investment @entity {
  id: ID!
  investmentManagerAddress: Bytes!
  amount: BigDecimal!
  poolTokenId: PoolToken!
  timestamp: Int!
}

type PoolSnapshot @entity {
  id: ID!
  pool: Pool!
  amounts: [BigDecimal!]
  totalShares: BigDecimal!
  timestamp: Int!
}
