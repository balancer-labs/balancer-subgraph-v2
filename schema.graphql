# Vault
type Balancer @entity {
  id: ID! # balancer ID
  poolCount: Int! # how many pools
  pools: [Pool!] @derivedFrom(field: "vaultID") # choose which pool

  totalLiquidity: BigDecimal! # how many liquidity pool has
  totalSwapCount: BigInt! # quantity of swaps
  totalSwapVolume: BigDecimal! # how much volume has been swapped
  totalSwapFee: BigDecimal! # how much fees collected
}

type Pool @entity {
  id: ID! # smart contract id of pool
  address: Bytes! # address of user
  poolType: String # which tpe of balancer pool
  poolTypeVersion: Int
  factory: Bytes # time-based pause configuration
  strategyType: Int! # strategy type (1 or 2)
  oracleEnabled: Boolean! # check wether oracle is enabled
  symbol: String # pool token symbol
  name: String # pool token name
  swapEnabled: Boolean! # check wether oracle is enabled
  swapFee: BigDecimal! # pool swap fee
  owner: Bytes # pool owner address


  totalWeight: BigDecimal # total weight
  totalSwapVolume: BigDecimal! # total swap volume in USD
  totalSwapFee: BigDecimal! # total swap fee in USD
  totalLiquidity: BigDecimal! # total liqidity in pool
  totalShares: BigDecimal! # total pool token shares

  createTime: Int! # block time pool was created
  swapsCount: BigInt! # pool swaps count
  holdersCount: BigInt! # total number of LP in that pool

  vaultID: Balancer! # vault ID
  tx: Bytes # Pool creation transaction id

  tokensList: [Bytes!]! #array of token address in pool

  tokens: [PoolToken!] @derivedFrom(field: "poolId") # tokens in pool
  swaps: [Swap!] @derivedFrom(field: "poolId") # swaps in pool
  shares: [PoolShare!] @derivedFrom(field: "poolId") # shares in pool
  snapshots: [PoolSnapshot!] @derivedFrom(field: "pool") #snapshot of pool
  historicalValues: [PoolHistoricalLiquidity!] @derivedFrom(field: "poolId") # pool historical values and liquidity


  # LiquidityBootstrappingPool Only
  weightUpdates: [GradualWeightUpdate!] @derivedFrom(field: "poolId") # weight update values

  # StablePool Only
  amp: BigInt # amplification paramenters

  # MetaStablePool and LinearPool Only
  priceRateProviders: [PriceRateProvider!] @derivedFrom(field: "poolId")

  # ConvergentCurvePool (Element) Only
  principalToken: Bytes # principal token
  baseToken: Bytes # base token
  expiryTime: BigInt # pool expiry time
  unitSeconds: BigInt # unit seconds

  # InvestmentPool Only
  managementFee: BigDecimal # pool management fee


  # LinearPool Only
  mainIndex: Int # pool main index
  wrappedIndex: Int  # pool wrapped index
  lowerTarget: BigDecimal # lower target
  upperTarget: BigDecimal # upper targer

  # Gyro2Pool Only
  sqrtAlpha: BigDecimal # square root of alpha
  sqrtBeta: BigDecimal # square root of beta

  # Gyro3Pool Only
  root3Alpha: BigDecimal # cube root of alpha

  # GyroEPool Only
  c: BigDecimal
  s: BigDecimal
  tauAlphaX: BigDecimal
  tauAlphaY: BigDecimal
  tauBetaX: BigDecimal
  tauBetaY: BigDecimal
  u: BigDecimal
  v: BigDecimal
  w: BigDecimal
  z: BigDecimal
  dSq: BigDecimal

  # GyroEPool+FXPool Only
  alpha: BigDecimal
  beta: BigDecimal
  lambda: BigDecimal

  # FXPool Only
  delta: BigDecimal
  epsilon: BigDecimal

  # Composable and WeightedV2 Only
  protocolSwapFeeCache: BigDecimal
  protocolYieldFeeCache: BigDecimal
  protocolAumFeeCache: BigDecimal
}

type PoolContract @entity {
  id: ID! # contract of pool
  pool: Pool! # a unigue identifier for each pool
}

type PoolToken @entity {
  id: ID! # pool token ID
  poolId: Pool # a unigue identifier for each pool
  token: Token! # token id
  assetManager: Bytes! # mint / burn address
  symbol: String! # pool token symbol
  name: String! # name of pool token symbol
  decimals: Int! # the number of decimals for your token
  address: String! # pool token address
  priceRate: BigDecimal! # conversion of token swapped
  balance: BigDecimal! # token balance of pool token
  cashBalance: BigDecimal! # cash balance of pool token
  managedBalance: BigDecimal! # managed balance
  managements: [ManagementOperation!] @derivedFrom(field: "poolTokenId") # management values

  # WeightedPool Only
  weight: BigDecimal # percentage of token of weighted pool

  # ComposableStablePool Only
  isExemptFromYieldProtocolFee: Boolean

  # FXPool Only
  assimilator: Bytes
}

type PriceRateProvider @entity {
  id: ID! # Id of contract
  poolId: Pool! # a unigue identifier for each pool
  token: PoolToken! # token of the pool
  address: Bytes! # address of each token
  rate: BigDecimal # rate of quoted swap
  lastCached: Int # timestamp of last quoted price
  cacheDuration: Int # how long estimate rate will last
  cacheExpiry: Int # timestamp of price expiration
}

type PoolShare @entity {
  id: ID! # pool share ID
  userAddress: User! # user wallet address
  poolId: Pool! # a unigue identifier for each pool
  balance: BigDecimal! # balance of pool
}

type User @entity {
  id: ID! # user ID
  sharesOwned: [PoolShare!] @derivedFrom(field: "userAddress") # how many shares user owns
  swaps: [Swap!] @derivedFrom(field: "userAddress") # how many swaps user has made
  userInternalBalances: [UserInternalBalance!]
    @derivedFrom(field: "userAddress") # balance for user
}

type UserInternalBalance @entity {
  id: ID! # user internal balance ID
  userAddress: User # wallet address
  token: Bytes! # token checking balance on
  balance: BigDecimal! # balance of token
}

type GradualWeightUpdate @entity {
  id: ID! # ID
  poolId: Pool! # a unigue identifier for each pool
  scheduledTimestamp: Int! # scheduled time LP token weight change
  startTimestamp: BigInt! # start time of update
  endTimestamp: BigInt! # end time of update
  startWeights: [BigInt!]! # weight of tokens in each LP pair before update
  endWeights: [BigInt!]! # weight of tokens in each LP pair ater update
}

type AmpUpdate @entity {
  id: ID! # amp update
  poolId: Pool! # a unigue identifier for each pool
  scheduledTimestamp: Int! # scheduled time of amp update
  startTimestamp: BigInt! # Start time of update
  endTimestamp: BigInt! # end time of update
  startAmp: BigInt! # amount of amp prior to update
  endAmp: BigInt! # amount of amp after update
}

type SwapFeeUpdate @entity {
  id: ID! # swap-{ Transaction hash }-{ Log index }
  pool: Pool! # a unigue identifier for each pool
  scheduledTimestamp: Int! # schedule time for swap
  startTimestamp: BigInt! # start time for swap
  endTimestamp: BigInt! # end time for swap
  startSwapFeePercentage: BigDecimal! # percent of fees when swap starts
  endSwapFeePercentage: BigDecimal! # # percent of fees when swap ends
}

type Swap @entity {
  id: ID! # swap-{ Transaction hash }-{ Log index }
  caller: Bytes! # pool controller
  tokenIn: Bytes! # token deposited into pool
  tokenInSym: String! # symbol of token swapped in
  tokenOut: Bytes! # token withdrawn from pool
  tokenOutSym: String! # symbol of token swapped out
  tokenAmountIn: BigDecimal! # total native token deposited
  tokenAmountOut: BigDecimal! # total native token withdrawn
  valueUSD: BigDecimal! # value in USD
  poolId: Pool! # a unigue identifier for each pool
  userAddress: User! # user wallet address
  timestamp: Int! # timestamp of this even
  tx: Bytes! # fee for swap
}

enum InvestType {
  Join
  Exit
}

type JoinExit @entity {
  id: ID! # ID of the pool you're interacting with
  type: InvestType! # JoinKind or ExitKind
  sender: Bytes! # address of sender
  amounts: [BigDecimal!]! # amounts during entry and exit
  valueUSD: BigDecimal # value of join in USD
  pool: Pool! # pool ID
  user: User! # Joins encodes JoinKind, Exits encode ExitKind
  timestamp: Int! # time stamp of join or exit
  tx: Bytes! # fee paid
}

type LatestPrice @entity {
  id: ID! # ID
  asset: Bytes! # token address
  pricingAsset: Bytes! # address of stable asset
  poolId: Pool! # last pool which set price
  price: BigDecimal! # all the latest prices
  block: BigInt! # last block that prices were updated
}

type PoolHistoricalLiquidity @entity {
  id: ID! # ID
  poolId: Pool! # a unigue identifier for each pool
  poolTotalShares: BigDecimal! # total pool shares
  poolLiquidity: BigDecimal! # total value, priced in the stable asset - ie USD
  poolShareValue: BigDecimal! # total pool value
  pricingAsset: Bytes! # address of stable asset # address of stable asset
  block: BigInt! # last block that prices were updated
}

type TokenPrice @entity {
  id: ID! # address of token + address of stablecoin-poolId
  poolId: Pool! # a unigue identifier for each pool
  asset: Bytes! # list of assets
  amount: BigDecimal! # amount of token
  pricingAsset: Bytes! # address of stable asset
  price: BigDecimal! # price of token
  block: BigInt! # last block that prices were updated
  timestamp: Int! # time price is checked
}

enum OperationType {
  Deposit
  Withdraw
  Update
}

type ManagementOperation @entity {
  id: ID! # ID
  type: OperationType! # operation type
  cashDelta: BigDecimal! # change in cash since last cash delta point
  managedDelta: BigDecimal! # change in managed amount since last delta point
  poolTokenId: PoolToken! # a unigue identifier for each pool
  timestamp: Int! # timestamp operation occurs
}

type PoolSnapshot @entity {
  id: ID! # pool snapshot ID
  pool: Pool! # name of pools included
  amounts: [BigDecimal!]! # amount of pools included
  totalShares: BigDecimal! # total shares of pool before vote
  swapVolume: BigDecimal! # total volume of pool before vote
  swapFees: BigDecimal! # swap fee of pool before vote
  liquidity: BigDecimal! # total liquidity of pool before vote
  swapsCount: BigInt! # total swaps count
  holdersCount: BigInt! # total holders count
  timestamp: Int! # time snapshot occurs
}

type Token @entity {
  id: ID! # Smart contract address of the token
  symbol: String # symbol of token
  name: String # name of token
  decimals: Int! # the number of decimals for your token
  address: String! # token address
  totalBalanceUSD: BigDecimal! # total balance of tokens across balancer
  totalBalanceNotional: BigDecimal! # total unrealized balance
  totalVolumeUSD: BigDecimal! # total volume in fiat (usd)
  totalVolumeNotional: BigDecimal! # total unrealized volume
  totalSwapCount: BigInt! # total swap count for token
  latestPrice: LatestPrice # latest price of token, updated when pool liquidity changes
  latestUSDPrice: BigDecimal # latest price of token in USD, updated when pool liquidity changes
  pool: Pool # pool entity associated with the token, if it is a Balancer pool
}

type TokenSnapshot @entity {
  id: ID! # token address + dayId
  token: Token! # which token or crypto
  timestamp: Int! # timestamp representing the start of day in UTC
  totalBalanceUSD: BigDecimal! # total balance of tokens across balancer
  totalBalanceNotional: BigDecimal! # underlying asset balance
  totalVolumeUSD: BigDecimal! # amount of volume the token has moved on this day
  totalVolumeNotional: BigDecimal! # underyling asset volume
  totalSwapCount: BigInt! # total swap count accross balancer
}

type TradePair @entity {
  id: ID! # Token Address - Token Address
  token0: Token! # Token 1 of trading pair
  token1: Token! # Token 2 of trading part
  totalSwapVolume: BigDecimal! # Total swap volume of pair
  totalSwapFee: BigDecimal! # Total swap fees of pair
}

type TradePairSnapshot @entity {
  id: ID! # user eth address
  pair: TradePair! # trading pair used in vote
  timestamp: Int! # time snapshot took place
  totalSwapVolume: BigDecimal! # total volume at time of snapshot
  totalSwapFee: BigDecimal! # total swap fees at time of snapshot
}

type BalancerSnapshot @entity {
  id: ID! # User eth address
  vault: Balancer! # which vault is associated to vote
  timestamp: Int! # time snapshot took place
  poolCount: Int! # how many pools in vote
  totalLiquidity: BigDecimal! # total liquidity of pools in vote
  totalSwapCount: BigInt! # total swapcount of pools in vote
  totalSwapVolume: BigDecimal! # total swap volome of pools in vote
  totalSwapFee: BigDecimal! # total swap fees of pools in vote
}
